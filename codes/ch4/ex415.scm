;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
(define (run-forever)
  (run-forever))

(define (try p)
  (if (halts? p p)
      (run-forever)
      'halted))

(try try)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; 该题证明了停机问题无解。停机问题有解即对与任何程序，存在一个判定程序 halts? 可以
;;;; 有限步之内判定其是否停机。
;;;; 如果存在 halts? 函数，那么其可以判断任何过程是终止还是一直运行，(halts? p i)
;;;; 表示程序 p 在输入 i 下面的终止情况。
;;;; 此时定义一个过程 try ，其输入是另一个过程 p ，如果 将 p 作为程序，p 本身作为输入
;;;; halts? 可以终止，那么 try 进入死循环，
;;;; 如果 p 不能终止，即 halts? 返回假，那么 try 终止。
;;;; 考虑 try 应用到 try (因为 try 本身也是一个过程，因此可以应用。
;;;; 如果 try 终止，try 可以在有限步内终止，那么 (try try) 也应该在有限步内终止，但是 (try try)
;;;; 的结果是 (run-forever), 如果 try 不终止，即 try 本身不能在有限步内终止，根据 (try try) 的定义，
;;;; (try try) 又在有限步之内终止。因此不可能有合适的 halts?
