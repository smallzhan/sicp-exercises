;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 首先考虑不带环的检查 3.16 的修改。实际上，可以首先加上一个环检查，见 318
;; 以及 319
;; 我们假定空序对也是序对？ 序对到底是什么？ 这里的定义为 () 包起来的任何东西。
;; 即任何可以进行 car 和 cdr 操作的东西。并且我们只统计最外面的，即
;; '((((((((((a b c)))))))))) 都算一个序对。
;; 并且'(a b c d e) 也只算一个。 貌似有点违背题目意思？
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; 暂时的结果是这样，待修改

(define (count-pairs x)
  (cond ((null? x) 1)
        ((not (pair? x)) 0)
        (else
         (let ((head (car x))
               (tail (cdr x)))
           (if (not (pair? tail))
               (if (not (pair? head))
                   1
                   (count-pairs head))
               (+ (count-pairs head)
                  (count-pairs tail)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3.17 是说返回不一样的版本，要有个序对的 eq 的，对上面的过程进行加工就可以了。
